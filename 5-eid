import argparse
import sys
import time
import numpy as np
import RPi.GPIO as GPIO
from picamera2 import Picamera2, MappedArray, CompletedRequest
from picamera2.devices import IMX500
from picamera2.devices.imx500 import NetworkIntrinsics
from picamera2.devices.imx500.postprocess import softmax
import cv2

# Traffic Light GPIO Setup
RED_LIGHT_A = 17
YELLOW_LIGHT_A = 27
GREEN_LIGHT_A = 22

RED_LIGHT_B = 5
YELLOW_LIGHT_B = 6
GREEN_LIGHT_B = 13

GPIO.setmode(GPIO.BCM)
GPIO.setup([RED_LIGHT_A, YELLOW_LIGHT_A, GREEN_LIGHT_A, RED_LIGHT_B, YELLOW_LIGHT_B, GREEN_LIGHT_B], GPIO.OUT)

# Initialize global variables
LABELS = None
ambulance_detected = False
last_detection_time = 0

# Traffic light control functions
def set_traffic_light_a(color):
    GPIO.output([RED_LIGHT_A, YELLOW_LIGHT_A, GREEN_LIGHT_A], GPIO.LOW)
    if color == "red":
        GPIO.output(RED_LIGHT_A, GPIO.HIGH)
    elif color == "yellow":
        GPIO.output(YELLOW_LIGHT_A, GPIO.HIGH)
    elif color == "green":
        GPIO.output(GREEN_LIGHT_A, GPIO.HIGH)

def set_traffic_light_b(color):
    GPIO.output([RED_LIGHT_B, YELLOW_LIGHT_B, GREEN_LIGHT_B], GPIO.LOW)
    if color == "red":
        GPIO.output(RED_LIGHT_B, GPIO.HIGH)
    elif color == "yellow":
        GPIO.output(YELLOW_LIGHT_B, GPIO.HIGH)
    elif color == "green":
        GPIO.output(GREEN_LIGHT_B, GPIO.HIGH)

# Classification callback
def parse_classification_results(request: CompletedRequest):
    global ambulance_detected, last_detection_time

    np_outputs = imx500.get_outputs(request.get_metadata())
    if np_outputs is None:
        return []

    np_output = np_outputs[0]

    if intrinsics.softmax:
        np_output = softmax(np_output)

    top_indices = np.argpartition(-np_output, 1)[:1]
    top_indices = top_indices[np.argsort(-np_output[top_indices])]

    last_detections = []
    for index in top_indices:
        label = get_label(request, index)
        score = np_output[index]
        last_detections.append((label, score))

    ambulance_detected = any("ambulance" in label.lower() for label, _ in last_detections)
    if ambulance_detected:
        last_detection_time = time.time()

    draw_classification_results(request, last_detections)
    return last_detections

def get_label(request: CompletedRequest, idx: int) -> str:
    global LABELS
    if LABELS is None:
        LABELS = intrinsics.labels
        assert len(LABELS) in [1000, 1001], "Labels file should contain 1000 or 1001 labels."
        output_tensor_size = imx500.get_output_shapes(request.get_metadata())[0][0]
        if output_tensor_size == 1000:
            LABELS = LABELS[1:]
    return LABELS[idx]

def draw_classification_results(request: CompletedRequest, results: list, stream="main"):
    with MappedArray(request, stream) as m:
        if intrinsics.preserve_aspect_ratio:
            b_x, b_y, b_w, b_h = imx500.get_roi_scaled(request)
            color = (255, 0, 0)
            cv2.putText(m.array, "ROI", (b_x + 5, b_y + 15), cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 1)
            cv2.rectangle(m.array, (b_x, b_y), (b_x + b_w, b_y + b_h), color, 1)

        for idx, (label, score) in enumerate(results):
            text = f"{label}: {score:.3f}"
            (text_width, text_height), baseline = cv2.getTextSize(text, cv2.FONT_HERSHEY_SIMPLEX, 0.5, 1)
            text_x = 5
            text_y = 20 + idx * 20

            overlay = m.array.copy()
            cv2.rectangle(overlay, (text_x, text_y - text_height), (text_x + text_width, text_y + baseline),
                          (255, 255, 255), cv2.FILLED)
            alpha = 0.3
            cv2.addWeighted(overlay, alpha, m.array, 1 - alpha, 0, m.array)
            cv2.putText(m.array, text, (text_x, text_y), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 255), 1)

# Traffic control logic
def normal_traffic_cycle():
    # Traffic Light A red, B green
    set_traffic_light_a("red")
    set_traffic_light_b("green")
    wait_with_detection(13)

    # Traffic Light B yellow
    set_traffic_light_b("yellow")
    wait_with_detection(3)

    # Traffic Light B red, A green
    set_traffic_light_b("red")
    set_traffic_light_a("green")
    wait_with_detection(13)

    # Traffic Light A yellow
    set_traffic_light_a("yellow")
    wait_with_detection(3)

def handle_ambulance_emergency():
    print("ðŸš¨ Handling ambulance emergency...")

    # Traffic Light B yellow
    set_traffic_light_b("yellow")
    time.sleep(3)

    # Traffic Light B red
    set_traffic_light_b("red")
    time.sleep(1)

    # Traffic Light A green (allow ambulance to pass)
    set_traffic_light_a("green")
    time.sleep(13)

    # After emergency, reset to normal cycle
    set_traffic_light_a("yellow")
    time.sleep(3)

def wait_with_detection(duration):
    """Wait for 'duration' seconds, but check for ambulance detection."""
    global ambulance_detected, last_detection_time

    start_time = time.time()
    while time.time() - start_time < duration:
        if ambulance_detected and (time.time() - last_detection_time) < 2:
            handle_ambulance_emergency()
            ambulance_detected = False
            break
        time.sleep(0.1)

# Main program
def main():
    picam2 = Picamera2(imx500.camera_num)
    config = picam2.create_preview_configuration(controls={"FrameRate": intrinsics.inference_rate}, buffer_count=12)
    picam2.start(config, show_preview=True)
    picam2.pre_callback = parse_classification_results

    while True:
        normal_traffic_cycle()

def get_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("--model", type=str, help="Path to the model",
                        default="/usr/share/imx500-models/imx500_network_mobilenet_v2.rpk")
    parser.add_argument("--fps", type=int, help="Frames per second")
    parser.add_argument("-s", "--softmax", action="store_true", help="Apply softmax post-processing")
    parser.add_argument("-r", "--preserve-aspect-ratio", action="store_true", help="Preserve aspect ratio")
    parser.add_argument("--labels", type=str, help="Path to labels file")
    return parser.parse_args()

if __name__ == "__main__":
    args = get_args()

    imx500 = IMX500(args.model)
    intrinsics = imx500.network_intrinsics or NetworkIntrinsics()
    if intrinsics.task != "classification":
        print("Network is not a classification task", file=sys.stderr)
        sys.exit()

    if args.labels:
        with open(args.labels, 'r') as f:
            intrinsics.labels = f.read().splitlines()

    intrinsics.update_with_defaults()

    try:
        main()
    except KeyboardInterrupt:
        print("Shutting down gracefully...")
    finally:
        GPIO.cleanup()
